<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>WORK_ORDER_EM</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        body { font-family: Arial; font-size: 12px; margin: 12px; }
        .filter-container { margin-bottom: 12px; padding: 10px; background-color: #f7f7f7; border-radius: 6px; }
        .filter-container label { margin-right: 8px; font-size: 13px; }
        table { border-collapse: collapse; width: 100%; margin-top: 8px; }
        th, td { border: 1px solid #ccc; padding: 6px; }
        th { background-color: #eee; cursor: pointer; user-select: none; }
        th.sort-asc::after { content: " ▲"; font-size: 10px; color: #333; }
        th.sort-desc::after { content: " ▼"; font-size: 10px; color: #333; }
    </style>
</head>
<body>
    <h2>WORK_ORDER_EM</h2>
    <div class="filter-container">
        <label>Room: <input type="text" id="filter-room" placeholder="filter Room"></label>
        <label>Order: <input type="text" id="filter-order" placeholder="filter Order"></label>
        <label>MAT: <input type="text" id="filter-mat" placeholder="filter MAT"></label>
        <label>Section: <input type="text" id="filter-section" placeholder="filter Section"></label>
        <label>CPH: <input type="text" id="filter-cph" placeholder="filter CPH"></label>
        <label>Status: <input type="text" id="filter-status" placeholder="filter Status"></label>
        <br><br>
        <input type="file" id="upload" accept=".xlsx" />
        <button id="clear-filters" style="margin-left:12px;">Clear filters</button>
    </div>

    <!-- kosongkan table, skrip akan bangun thead/tbody via DOM -->
    <table id="wo-table"></table>

    <script>
    // ====== helpers ======
    function formatDateFromSerialOrDate(v) {
        if (v === null || v === undefined || v === '') return "";
        const options = { day: '2-digit', month: 'short', year: 'numeric' };
        if (v instanceof Date) return v.toLocaleDateString('en-US', options).replace(/ /g, '-');
        if (typeof v === 'number') {
            const date = new Date(Math.round((v - 25569) * 86400 * 1000));
            return date.toLocaleDateString('en-US', options).replace(/ /g, '-');
        }
        const parsed = Date.parse(String(v));
        if (!isNaN(parsed)) return new Date(parsed).toLocaleDateString('en-US', options).replace(/ /g, '-');
        return String(v);
    }

    function formatCurrency(value) {
        if (value === null || value === undefined || value === '') return "";
        const num = Number(String(value).replace(/[^0-9.-]/g, ''));
        return !isNaN(num) ? ("$" + Math.round(num).toLocaleString()) : String(value);
    }

    function applyStyleToTd(td, col, valText) {
        col = (col || '').toString().trim().toLowerCase();
        valText = (valText === null || valText === undefined) ? '' : String(valText).trim();
        // alignment
        if (["order","created on","planning","target date","end date","cost","include","exclude"].includes(col)) {
            td.style.textAlign = "right";
        } else if (["user status","mat"].includes(col)) {
            td.style.textAlign = "center";
        } else {
            td.style.textAlign = "left";
        }

        // background colors
        if (col === "status part") {
            if (valText === "Complete") { td.style.backgroundColor = "green"; td.style.color = "white"; }
            else if (valText === "Not Complete") { td.style.backgroundColor = "red"; td.style.color = "white"; }
        } else if (col === "aging") {
            const aging = parseInt(valText);
            if (!isNaN(aging)) {
                td.style.backgroundColor = (aging <= 30) ? "green" : "red";
                td.style.color = "white";
            }
        } else if (col === "status amt") {
            if (valText === "O") { td.style.backgroundColor = "lightgray"; td.style.color = "black"; }
            else if (valText === "YTS") { td.style.backgroundColor = "green"; td.style.color = "white"; }
            else if (valText === "IP") { td.style.backgroundColor = "orange"; td.style.color = "red"; }
            else if (valText === "C") { td.style.backgroundColor = "black"; td.style.color = "white"; }
        }
    }

    function parseValueForSort(text) {
        const s = (text === null || text === undefined) ? '' : String(text).trim();
        if (s === '') return '';
        // try number
        const num = Number(s.replace(/[^0-9.\-]/g, ''));
        if (!isNaN(num) && /[0-9]/.test(s)) return num;
        // try date
        const parsed = Date.parse(s);
        if (!isNaN(parsed)) return parsed;
        return s.toLowerCase();
    }

    function clearSortIndicators(tableEl) {
        if (!tableEl) return;
        tableEl.querySelectorAll('th').forEach(th => {
            th.classList.remove('sort-asc','sort-desc');
            delete th.dataset.sorted;
        });
    }

    // ====== globals ======
    let currentHeaders = []; // header text array

    // ====== sorting (by column index) ======
    function sortTableByIndex(colIndex, thElement) {
        const table = document.getElementById('wo-table');
        if (!table) return;
        const tbody = table.tBodies[0];
        if (!tbody) return;

        const asc = thElement.dataset.sorted !== 'asc';
        clearSortIndicators(table);
        thElement.dataset.sorted = asc ? 'asc' : 'desc';
        thElement.classList.add(asc ? 'sort-asc' : 'sort-desc');

        const rows = Array.from(tbody.rows);
        rows.sort((a, b) => {
            const aText = (a.cells[colIndex] && a.cells[colIndex].textContent) ? a.cells[colIndex].textContent : '';
            const bText = (b.cells[colIndex] && b.cells[colIndex].textContent) ? b.cells[colIndex].textContent : '';
            const va = parseValueForSort(aText);
            const vb = parseValueForSort(bText);

            if (typeof va === 'number' && typeof vb === 'number') return asc ? (va - vb) : (vb - va);
            if (typeof va === 'number') return asc ? -1 : 1;
            if (typeof vb === 'number') return asc ? 1 : -1;
            return asc ? String(va).localeCompare(String(vb)) : String(vb).localeCompare(String(va));
        });

        rows.forEach(r => tbody.appendChild(r));
    }

    // ====== filtering ======
    function getIndexByKeyword(keyword) {
        keyword = (keyword || '').toLowerCase();
        return currentHeaders.findIndex(h => (h || '').toLowerCase().includes(keyword));
    }

    function filterTable() {
        const fRoom = (document.getElementById("filter-room").value || '').toLowerCase();
        const fOrder = (document.getElementById("filter-order").value || '').toLowerCase();
        const fMat = (document.getElementById("filter-mat").value || '').toLowerCase();
        const fSection = (document.getElementById("filter-section").value || '').toLowerCase();
        const fCph = (document.getElementById("filter-cph").value || '').toLowerCase();
        const fStatus = (document.getElementById("filter-status").value || '').toLowerCase();

        const table = document.getElementById('wo-table');
        if (!table || !table.tBodies[0]) return;
        const rows = Array.from(table.tBodies[0].rows);

        const idxRoom = getIndexByKeyword('room');
        const idxOrder = getIndexByKeyword('order');
        const idxMat = getIndexByKeyword('mat');
        const idxSection = getIndexByKeyword('section');
        const idxCph = getIndexByKeyword('cph');
        const idxStatus = getIndexByKeyword('status');

        rows.forEach(row => {
            let show = true;
            if (fRoom && idxRoom >= 0) {
                const cell = (row.cells[idxRoom] && row.cells[idxRoom].textContent) ? row.cells[idxRoom].textContent.toLowerCase() : '';
                if (!cell.includes(fRoom)) show = false;
            }
            if (show && fOrder && idxOrder >= 0) {
                const cell = (row.cells[idxOrder] && row.cells[idxOrder].textContent) ? row.cells[idxOrder].textContent.toLowerCase() : '';
                if (!cell.includes(fOrder)) show = false;
            }
            if (show && fMat && idxMat >= 0) {
                const cell = (row.cells[idxMat] && row.cells[idxMat].textContent) ? row.cells[idxMat].textContent.toLowerCase() : '';
                if (!cell.includes(fMat)) show = false;
            }
            if (show && fSection && idxSection >= 0) {
                const cell = (row.cells[idxSection] && row.cells[idxSection].textContent) ? row.cells[idxSection].textContent.toLowerCase() : '';
                if (!cell.includes(fSection)) show = false;
            }
            if (show && fCph && idxCph >= 0) {
                const cell = (row.cells[idxCph] && row.cells[idxCph].textContent) ? row.cells[idxCph].textContent.toLowerCase() : '';
                if (!cell.includes(fCph)) show = false;
            }
            if (show && fStatus && idxStatus >= 0) {
                const cell = (row.cells[idxStatus] && row.cells[idxStatus].textContent) ? row.cells[idxStatus].textContent.toLowerCase() : '';
                if (!cell.includes(fStatus)) show = false;
            }
            row.style.display = show ? "" : "none";
        });
    }

    // small debounce to avoid firing filter too often while typing
    function debounce(fn, wait) {
        let t;
        return function(...args) {
            clearTimeout(t);
            t = setTimeout(() => fn.apply(this, args), wait);
        };
    }
    const debouncedFilter = debounce(filterTable, 120);

    // attach filter listeners
    document.querySelectorAll(".filter-container input[type=text]").forEach(inp => {
        inp.addEventListener('input', debouncedFilter);
    });

    document.getElementById('clear-filters').addEventListener('click', () => {
        document.querySelectorAll(".filter-container input[type=text]").forEach(inp => inp.value = '');
        filterTable();
    });

    // ====== upload & render using DOM APIs (no string-html building) ======
    document.getElementById('upload').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(ev) {
            const data = new Uint8Array(ev.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            if (!sheetName) return;
            const sheet = workbook.Sheets[sheetName];
            const json = XLSX.utils.sheet_to_json(sheet, { header: 1, raw: true });
            if (!json || json.length === 0) {
                alert('No data found in sheet');
                return;
            }

            // headers and rows
            currentHeaders = json[0].map(h => h === null || h === undefined ? '' : String(h).trim());
            const dataRows = json.slice(1);

            const table = document.getElementById('wo-table');
            // remove old children
            while (table.firstChild) table.removeChild(table.firstChild);

            // build thead
            const thead = document.createElement('thead');
            const headTr = document.createElement('tr');
            currentHeaders.forEach((h, idx) => {
                const th = document.createElement('th');
                th.textContent = h;
                th.dataset.colIndex = idx;
                th.style.cursor = 'pointer';
                th.addEventListener('click', () => sortTableByIndex(idx, th));
                headTr.appendChild(th);
            });
            thead.appendChild(headTr);
            table.appendChild(thead);

            // build tbody with fragment for performance
            const tbody = document.createElement('tbody');
            const frag = document.createDocumentFragment();
            dataRows.forEach(rowArr => {
                const tr = document.createElement('tr');
                for (let i = 0; i < currentHeaders.length; i++) {
                    const colName = currentHeaders[i] || '';
                    let rawVal = (rowArr && rowArr[i] !== undefined && rowArr[i] !== null) ? rowArr[i] : '';
                    let cellText = '';
                    const lc = colName.toLowerCase();
                    if (["created on","planning","target date","end date"].includes(lc)) {
                        cellText = formatDateFromSerialOrDate(rawVal);
                    } else if (["cost","include","exclude"].includes(lc)) {
                        cellText = formatCurrency(rawVal);
                    } else {
                        if (rawVal instanceof Date) cellText = formatDateFromSerialOrDate(rawVal);
                        else cellText = String(rawVal);
                    }
                    const td = document.createElement('td');
                    td.textContent = cellText;
                    applyStyleToTd(td, colName, cellText);
                    tr.appendChild(td);
                }
                frag.appendChild(tr);
            });
            tbody.appendChild(frag);
            table.appendChild(tbody);

            // apply active filters (if any)
            filterTable();
            // clear any sort markers
            clearSortIndicators(table);
        };
        reader.readAsArrayBuffer(file);
    });
    </script>
</body>
</html>
